<!doctype html>
<head>
<meta charset="utf-8">
<title>ScreenAR</title>
<meta name="description" content="ScreenAR from FXPAL">
<meta name="author" content="FXPAL">
<meta name="viewport" content="width=device-width,initial-scale=1">
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.7.0/css/font-awesome.min.css">
<style>
@font-face {
  font-family: 'Open Sans';
  font-style: normal;
  font-weight: 400;
  /*font-display: swap;*/
  src: local('Open Sans Regular'), local('OpenSans-Regular'), url(/static/fonts/open-sans.woff2) format('woff2');
  unicode-range: U+0000-00FF, U+0131, U+0152-0153, U+02BB-02BC, U+02C6, U+02DA, U+02DC, U+2000-206F, U+2074, U+20AC, U+2122, U+2191, U+2193, U+2212, U+2215, U+FEFF, U+FFFD;
}
body,
html {
    margin: 0;
    padding: 0;
}

* {
    touch-action: manipulation;
}

*,
*::before,
*::after {
    box-sizing: border-box;
}

:root{
--blue:#3d73d3;
--darkblue:#2d43c3;
--font:'Open Sans',-apple-system,sans-serif;
}

body{
  font-family:var(--font);
  display:flex;
  flex-direction:column;
  height:100vh;
  width:100vw;
}


#sourcecanvas{
  object-fit:contain;
  width:100%;
  height:100%;
  overflow:hidden;
  background-color:#222;
}

#correctedcanvas{
  position:absolute;
  right:16px;
  bottom:16px;
  background-color:black;
  width:320px;
  height:auto;
  border:3px solid var(--blue);
  border-radius: 3px;
}

/* first row of our flex */
.header{
  display:flex;
  flex-direction:row;
  justify-content:space-between;
  margin:16px;
  flex-grow:0;
  line-height:3rem;
}

/* second row of our flex where the main canvas and correctedcanvas are shown */
#screenarcontainer
{
  background-color:red;
  width:100%;height:100%;
  display:block;
  overflow:hidden;
  flex-grow:1; /* use all available height */
  position:relative;
}

/* last row of our flex where the indexed frames are shown */
#results{
  margin:0;
  overflow-x:auto;
  overflow-y:hidden;
  display:flex;
  flex-direction:row;
  width:100%;
  min-height:120px;
  border:0px solid black;
  flex-grow:0;
  position:relative;
}
#results:before{
  color:lightgray;
  margin:16px;
  font-size:13pt;z-index:0;
  content:'Results';
  position:absolute;
}

.snapshot{
  z-index:2;
  cursor:pointer;
  padding:0 8px;
  object-fit:contain;
  background-color:white;
  width:calc(100% / 6);height:100%;
}

mytitle{color:var(--blue);font-size:18pt;}

#video{display:none}

.mark{
padding:0.3%;
color:white;
font-size:30%;
opacity:0;
transform-origin:0 0;
position:absolute;
width:20%;height:20%;
transform:translate(-50%,-50%);
border:0px solid #ccc;
border-radius:2px;
background-color:rgba(0,0,255,0.3);
transition:opacity 0.3s ease-in-out;
}
.mark > span {
  background-color:rgba(0,0,0,0.2);
  position:absolute;left:0;top:0;
  width:100%;
  text-align:center;
}

.button {
  outline:none;
  padding: 8px 16px;
  margin-left:16px;
  text-align: center;
  text-decoration: none;
  display: inline-block;
  font-size: 13pt;
  font-family:var(--font);
  border:0;
  background-color:var(--blue);
  color:white;
  border-radius:3px;
  cursor:pointer;
  transition:background-color 0.2s;
}
.button:hover{background-color:var(--darkblue)}

/* prevents Swal from removing the flex and height */
.swal2-shown {
  display:flex;
  height:100vh;
}
#audioElement{display: none;}
</style>
<div class='header'>
  <mytitle>ScreenAR</mytitle>
  <audio id='audioElement' controls></audio>
  <div id='controlbuttons'>
    <button class='button'  onclick='stopSession()'>Stop Session</button>
    <button class='button' onclick='downloadARAnnotations(event)'>Download</button>
  </div>
</div>
<div id='screenarcontainer'>
  <canvas id='sourcecanvas'></canvas>
  <canvas id='correctedcanvas'></canvas>
  <div id='currentmarkdiv'></div>
</div>
<div id='results'>
  <!--img class='snapshot' src='https://www.google.com/logos/google.jpg'>
  <img class='snapshot' src='https://www.google.com/logos/google.jpg'>
  <img class='snapshot' src='https://www.google.com/logos/google.jpg'>
  <img class='snapshot' src='https://www.google.com/logos/google.jpg'>
  <img class='snapshot' src='https://www.google.com/logos/google.jpg'>
  <img class='snapshot' src='https://www.google.com/logos/google.jpg'>
  <img class='snapshot' src='https://www.google.com/logos/google.jpg'>
  <img class='snapshot' src='https://www.google.com/logos/google.jpg'>
  <img class='snapshot' src='https://www.google.com/logos/google.jpg'>
  <img class='snapshot' src='https://www.google.com/logos/google.jpg'-->
</div>
<div style='display:none'>
  <video id='video'></video>
</div>
<script src="/static/ext/socket.io/2.2.0/socket.io.js"></script>
<script src="/static/ext/glfx/glfx.js"></script>
<script src="/static/ext/glfx/jsfeat-min.js"></script>
<script src="/static/js/webrtc.js"></script>
<script src="/static/js/connected-component-labelling.js"></script>
<script src="/static/ext/js-zip/jszip.min.js"></script>
<script src="/static/ext/sweetalert/sweetalert2.js"></script>
<script>
window.config = { room: 'fxpal' }

//var corners = null;
var fxcanvas = fx.canvas();
var canvas = document.getElementById('sourcecanvas');
var canvasw = 480;
var canvash = 320;
canvas.width = canvasw;
canvas.height = canvash;
var ctx = canvas.getContext('2d');

var correctedcanvas = document.getElementById('correctedcanvas');
correctedcanvas.width = 640;//canvasw;
correctedcanvas.height = 360;//canvash;
var correctedctx = correctedcanvas.getContext('2d');

// setup sample video
var constraints = {
    video: false,
    audio: true
}

//let skinDetected = false;
//let skinTimeout = null;

var dataChannelCallback = function(data) {
  //console.log('dataChannelCallback data=',data);
  /*if (data === 'skin')
  {
    clearTimeout(skinTimeout);
    skinDetected = true;
    console.error('skin detected');
    skinTimeout = setTimeout(function () { skinDetected = false; },30);
    return;
  }*/
  let anchorSize = [];
  data.split(',').forEach(i => anchorSize.push(parseInt(i)));
  let anchorWidth = anchorSize[0];
  let anchorHeight = anchorSize[1];
  let newWidth = 640;
  let newHeight = ((640 * anchorHeight) / anchorWidth) | 0;
  if (correctedcanvas.width !== newWidth || correctedcanvas.height !== newHeight)
  {
    correctedcanvas.width = newWidth;
    correctedcanvas.height = newHeight;
    console.log('correctedcanvas width/height=',correctedcanvas.width,correctedcanvas.height);
  }
}

var wrtc;
var mediaRecorder = null;
var videoRecorder = null;
var recordedCroppedChunks = [];
var recordedChunks = [];
var captureTimeout = null;
var lastImage = null;
var anchorPoints = [];
var sessionStarted = false;
var sessionStopped = false;
var stopSessionTimeout = null;


function initRecordingVideo(videostream)
{
  let videoRecorder = new MediaRecorder(videostream);
  let recordedVideoChunks = [];
  videoRecorder.addEventListener('dataavailable', function(e) {
    if (e.data.size > 0) {
      recordedVideoChunks.push(e.data);
    }
  });

  videoRecorder.addEventListener('stop', function() {
    console.log('videoRecorder stopped');
    let videoBlob = new Blob(recordedVideoChunks);
    let dlAnchorElem = document.createElement('a');
    dlAnchorElem.textContent = 'download screenar.mp4';
    dlAnchorElem.setAttribute('href',URL.createObjectURL(videoBlob));
    dlAnchorElem.setAttribute('download', 'screenar.mp4');
    //dlAnchorElem.click();
    document.querySelector('#controlbuttons').appendChild(dlAnchorElem);
  });

  return videoRecorder;
}

function initAudioRecorder(audiostream)
{
    mediaRecorder = new MediaRecorder(audiostream);
    mediaRecorder.addEventListener('dataavailable', function(e) {
      if (e.data.size > 0) {
        recordedChunks.push(e.data);
      }
    });

    mediaRecorder.addEventListener('stop', function() {
      console.log('stopped');
      let blob = new Blob(recordedChunks);
      audioElement.src = URL.createObjectURL(blob);
      recordedChunks = [];
    });
}

let params = new URLSearchParams(window.location.search);
if (params.get('video'))
{
  let video = document.querySelector('#video');
  video.src = '/static/videoStor/' + params.get('video');
  video.autoplay = true;
}
else {
  navigator.mediaDevices.getUserMedia(constraints).then(
      function(stream) {
          wrtc = new WebRTCClient({ stream: stream, dataChannel:'ScreenAR', dataChannelCallback: dataChannelCallback, room: config.room });
          wrtc.on('stream', function(id, stream) {
              let video = document.querySelector('#video');
              video.srcObject = stream;
              var audioTracks = stream.getAudioTracks();
              if (audioTracks && audioTracks.length > 0)
              {
                var audioMediaStream = stream.clone();
                audioMediaStream.removeTrack(audioMediaStream.getVideoTracks()[0]);
                initAudioRecorder(audioMediaStream);
                audioElement.style.display = 'block';
              }
              videoRecorder = initRecordingVideo(stream);
              video.autoplay = true;
          });
      }
  );
}

function drawVideo()
{
  if (canvas.width !== video.videoWidth || canvas.height !== video.videoHeight)
  {
    canvasw = video.videoWidth;
    canvash = video.videoHeight;

    console.log('new video width/height=',canvasw,canvash)

    canvas.width = canvasw;
    canvas.height = canvash;

    fxcanvas = fx.canvas();
    fxcanvas.width = canvasw;
    fxcanvas.height = canvash;

  }
  ctx.drawImage(video,0,0,canvasw,canvash);
  let corners = detectCorners(ctx);
  if (corners !== null)
  {
    if (sessionStarted === false)
    {
      console.log('started audio recording',corners);
      sessionStarted = true;
      if (mediaRecorder)
        mediaRecorder.start();
      if (videoRecorder)
        videoRecorder.start();
    }

    let texture = fxcanvas.texture(canvas);
    fxcanvas.draw(texture).perspective(
      [corners.tl.x,corners.tl.y,corners.tr.x,corners.tr.y,corners.br.x,corners.br.y,corners.bl.x,corners.bl.y],
      [0,0,canvasw,0,canvasw,canvash,0,canvash]).update();
    correctedctx.drawImage(fxcanvas,0,0,correctedcanvas.width,correctedcanvas.height);

    //binarize(correctedcanvas);
    canny(correctedcanvas);

    let fingerPosition = detectFingerTip(correctedctx.getImageData(0,0,correctedcanvas.width,correctedcanvas.height));
    if (fingerPosition)
    {
      currentAnchor.points.push(fingerPosition);
      clearTimeout(captureTimeout);
      captureTimeout = null;
      correctedctx.fillStyle = 'yellow';
      correctedctx.font = '24px Arial';
      correctedctx.fillText('HAND',40,40);

      correctedctx.fillStyle = 'red';
      correctedctx.beginPath();
      correctedctx.ellipse(fingerPosition.x,fingerPosition.y,8,8,0,0,2*Math.PI);
      correctedctx.fill();
    }
    else
    {
      if (sessionStopped === false && captureTimeout === null)
        captureTimeout = setTimeout(captureImage,1000);
    }

  }
  else
  {
    /*if (sessionStopped === false && sessionStarted)
    {
      sessionStopped = true;
      stopSessionTimeout = setTimeout(stopSession,2000);
    }*/
    //correctedcanvas.style.opacity = 0.1;
    correctedctx.fillStyle = 'black';
    correctedctx.fillRect(0,0,correctedcanvas.width,correctedcanvas.height);
  }

  if (currentMark)
  {
    drawCurrentMark();
  }

  setTimeout(drawVideo,1000/10);
}

let currentAnchor = null;

function drawCurrentMark()
{
  //correctedctx.fillStyle = 'black';
  //correctedctx.fillRect(0,0,correctedcanvas.width,correctedcanvas.height);
  correctedctx.strokeStyle = 'yellow';
  correctedctx.lineWidth = 6;
  let x1 = Math.min(currentMark.px,currentMark.cx);
  let y1 = Math.min(currentMark.py,currentMark.cy);
  let x2 = Math.max(currentMark.px,currentMark.cx);
  let y2 = Math.max(currentMark.py,currentMark.cy);
  let w = x2 - x1;
  let h = y2 - y1;
  correctedctx.strokeRect(x1,y1,w,h);


}
function addARAnnotation(idx)
{
  let img = document.createElement('img');
  img.onload = function () {
    let canvas = document.createElement('canvas');
    let ctx = canvas.getContext('2d');
    canvas.className = 'snapshot';
    canvas.dataset.timestamp = anchorPoints[+this.dataset.index].timestamp;
    canvas.width = this.naturalWidth;
    canvas.height = this.naturalHeight;
    ctx.drawImage(this,0,0);
    let points = anchorPoints[+this.dataset.index].points;
    if (points && points.length > 1)
    {
      ctx.strokeStyle = 'rgba(0,0,255,0.8)';
      ctx.lineWidth = 4;
      ctx.beginPath();
      ctx.moveTo(points[0].x,points[0].y);
      for (let i=1;i<points.length;i++)
      {
        ctx.lineTo(points[i].x,points[i].y);
      }
      ctx.stroke();
    }
    canvas.addEventListener('click',function () {
      audioElement.currentTime = +this.dataset.timestamp;
      audioElement.play();
    });
    results.appendChild(canvas);
  }
  img.dataset.index = idx;
  img.src = anchorPoints[idx].src;
}

function uuidv4() {
  return ([1e7]+-1e3+-4e3+-8e3+-1e11).replace(/[018]/g, c =>
    (c ^ crypto.getRandomValues(new Uint8Array(1))[0] & 15 >> c / 4).toString(16)
  );
}

function stopSession()
{
  if (sessionStarted === false)
  {
    return Swal.fire({title:'No data',text:'The session has not yet started'});
  }
  if (currentAnchor !== null)
    addARAnnotation(anchorPoints.length-1);
  sessionStopped = true;
  console.log('stopSession');
  if (mediaRecorder)
    mediaRecorder.stop();
  if (videoRecorder)
    videoRecorder.stop();
}

function downloadARAnnotations(e)
{
  e.preventDefault();
  let button = e.target;
  button.innerHTML = '<i class="fa fa-circle-o-notch fa-spin"></i> Zipping';
  button.disabled = true;
  if (anchorPoints.length === 0)
  {
    Swal.fire({title:'Nothing to Zip',text:'No anchor points were added yet'}).then(e => {button.textContent = 'Download';
    button.disabled = false;}).catch();
    return;
  }

  var zip = new JSZip();
  let uuid = uuidv4();
  var img = zip.folder(uuid);
  img.file("rec.json", JSON.stringify(anchorPoints));
  zip.generateAsync({type:"base64"}).then(function (base64) {
    let baseurl = "data:application/zip;base64," + base64;
    fetch(baseurl)
    .then(res => res.blob())
    .then(blob => {
      setTimeout( function () {
        button.textContent = 'Download';
        button.disabled = false;
      },2000);
      var dlAnchorElem = document.createElement('a');
      dlAnchorElem.textContent = 'download zip file';
      dlAnchorElem.setAttribute('href',URL.createObjectURL(blob));
      dlAnchorElem.setAttribute('download', 'screenar.zip');
      dlAnchorElem.click();
    });
 });
}

function captureImage()
{
  if (currentAnchor !== null)
    addARAnnotation(anchorPoints.length-1);
  let lastImageSrc = correctedcanvas.toDataURL('image/jpeg',0.8);
  console.log('captureImage');
  currentAnchor = {points:[],src:lastImageSrc,timestamp:new Date().getTime()/1000}
  anchorPoints.push(currentAnchor);

  /*if (wrtc && wrtc.sendChannel)
  {
    let base64url = lastImageSrc.substring("data:image/jpeg;base64,".length);
    wrtc.sendChannel.send(base64url);
  }*/
}

function OneEuroFilter(freq, mincutoff, beta, dcutoff){
	var that = {};
	var x = LowPassFilter(alpha(mincutoff));
	var dx = LowPassFilter(alpha(dcutoff));
	var lastTime = undefined;

	mincutoff = mincutoff || 1;
	beta = beta || 0;
	dcutoff = dcutoff || 1;

	function alpha(cutoff){
		var te = 1 / freq;
		var tau = 1 / (2 * Math.PI * cutoff);
		return 1 / (1 + tau / te);
	}

	that.filter = function(v, timestamp){
		if(lastTime !== undefined && timestamp !== undefined)
			freq = 1 / (timestamp - lastTime);
		lastTime = timestamp;
		var dvalue = x.hasLastRawValue() ? (v - x.lastRawValue()) * freq : 0;
		var edvalue = dx.filterWithAlpha(dvalue, alpha(dcutoff));
		var cutoff = mincutoff + beta * Math.abs(edvalue);
		return x.filterWithAlpha(v, alpha(cutoff));
	}

	return that;
}

function LowPassFilter(alpha, initval){
	var that = {};
	var y = initval || 0;
	var s = y;

	function lowpass(v){
		y = v;
		s = alpha * v + (1 - alpha) * s;
		return s;
	}

	that.filter = function(v){
		y = v;
		s = v;
		that.filter = lowpass;
		return s;
	}

	that.filterWithAlpha = function(v, a){
		alpha = a;
		return that.filter(v);
	}

	that.hasLastRawValue = function(){
		return that.filter === lowpass;
	}

	that.lastRawValue = function(){
		return y;
	}

	return that;
}

var freq = 30;
var filterx = OneEuroFilter(freq, 1, 0.01, 1);
var filtery = OneEuroFilter(freq, 1, 0.01, 1);

function detectFingerTip(imgData) {
  let data = imgData.data;
  let canvasw = imgData.width;
  let canvash = imgData.height;
  let idx = 0;
  let miny = -1;
  let rows = {};
  let minx = canvasw;
  let maxx = 0;
  for (let y=0;y<canvash;y++)
  {
    for (let x=0;x<canvasw;x++)
    {
      if (data[idx] < 100 && data[idx+1] >= 250 && data[idx+2] < 100)
      {
        if (rows[y])
        {
          rows[y].min = Math.min(x,rows[y].min)
          rows[y].max = Math.max(x,rows[y].max)
        }
        else
        {
          rows[y] = {min:x,max:x};
        }
      }
      idx += 4;
    }
  }
  let middlex = 0;
  let nmiddle = 0;
  let meanwidth = 0;
  let top = -1;
  for (let y in rows)
  {
    let row = rows[y];
    if (row.max - row.min > 50)
    {
      if (top === -1)
        top = +y;
      middlex += (row.max + row.min) / 2;
      nmiddle++;
      meanwidth += row.max - row.min;
      //ctxtip.fillRect(row.min,y,row.max-row.min,1);
    }
    if (nmiddle > 10)
      break;
  }
  if (nmiddle >= 10)
  {
    middlex /= nmiddle;
		var filteredx = filterx.filter(middlex);
		var filteredy = filtery.filter(top);

    return {x:filteredx, y: filteredy};
  }
  else
    return null;
}

const th = 200; // threshold for white pixels
const blackth = 20; // threshold for dark pixels
const BORDER_SIZE = 2; // number of pixels to check for dark pixels around
function darkPixel(data,idx)
{
  return data[idx] < blackth && data[idx+1] < blackth && data[idx+2] < blackth;
}

function detectCorners(ctx)
{
  if (canvasw === 0 || canvash === 0)
  {
    return null;
  }
  let imgData = ctx.getImageData(0,0,canvasw,canvash);
  let data = imgData.data;
  let idx = 0;

  // top gives x positions of tl and tr corners

  let nDarkPixels = 0;

  let tl = {x:-1,y:-1};
  let tr = {x:-1,y:-1};

  // check that top is mostly dark
  nDarkPixels = 0;
  idx = 0;
  for (let j=0;j<BORDER_SIZE;j++)
  {
      for (let i=0;i<canvasw;i++)
      {
        if (darkPixel(data,idx))
          nDarkPixels++;
        idx += 4;
      }
  }

  if (nDarkPixels < BORDER_SIZE * canvasw * 90 /100)
  {
    return null;
  }

  // check that bottom is mostly dark
  nDarkPixels = 0;
  idx = (canvasw * (canvash-BORDER_SIZE)) * 4;
  for (let j=canvash-BORDER_SIZE;j<canvash;j++)
  {
      for (let i=0;i<canvasw;i++)
      {
        if (darkPixel(data,idx))
          nDarkPixels++;
        idx += 4;
      }
  }
  if (nDarkPixels < BORDER_SIZE * canvasw * 90 /100)
  {
    return null;
  }

  // check left and right are mostly dark
  let nDarkLeft = 0;
  let nDarkRight = 0;
  for (let j=0;j<canvash;j++)
  {
    for (let i=0;i<BORDER_SIZE;i++)
    {
      let indexLeft = 4 * (j * canvasw + i);
      if (darkPixel(data,indexLeft))
        nDarkLeft++;
      let indexRight = 4 * (j * canvasw + canvasw - i);
      if (darkPixel(data,indexRight))
        nDarkRight++;
    }
  }
  if (nDarkLeft < BORDER_SIZE * canvash * 90 /100)
  {
    return null;
  }
  if (nDarkRight < BORDER_SIZE * canvash * 90 /100)
  {
    return null;
  }

  // now find the white marks
  idx = 0;
  for (let i=0;i<canvasw;i++)
  {
    if (data[idx] >= th && data[idx+1] >= th && data[idx+2] >= th)
    {
      if (tl.x !== -1)
        tr.x = i;
      else
        tl.x = i;
    }
    idx += 4;
  }

  // bottom gives x positions of bl and br corners
  let bl = {x:-1,y:-1};
  idx = ((canvash - 1) * canvasw * 4);
  for (let i=0;i<canvasw;i++)
  {
    if (data[idx] >= th && data[idx+1] >= th && data[idx+2] >= th)
    {
      bl.x = i;
      break;
    }
    idx += 4;
  }

  let br = {x:-1,y:-1};
  idx = (canvash * canvasw * 4) - 4;
  for (let i=canvasw;i>=0;i--)
  {
    if (data[idx] >= th && data[idx+1] >= th && data[idx+2] >= th)
    {
      br.x = i;
      break;
    }
    idx -= 4;
  }

  // left gives y positions of tl and bl corners
  idx = 0;
  for (let i=0;i<canvash;i++)
  {
    if (data[idx] >= th && data[idx+1] >= th && data[idx+2] >= th)
    {
      tl.y = i;
      break;
    }
    idx += canvasw * 4;
  }

  idx = ((canvash - 1) * canvasw * 4);
  for (let i=canvash;i>=0;i--)
  {
    if (data[idx] >= th && data[idx+1] >= th && data[idx+2] >= th)
    {
      bl.y = i;
      break;
    }
    idx -= canvasw * 4;
  }

  // right gives y positions of tr and br corners
  idx = canvasw * 4 - 4;
  for (let i=0;i<canvash;i++)
  {
    if (data[idx] >= th && data[idx+1] >= th && data[idx+2] >= th)
    {
      tr.y = i;
      break;
    }
    idx += canvasw * 4;
  }

  idx = (canvash * canvasw * 4) - 4;
  for (let i=canvash;i>=0;i--)
  {
    if (data[idx] >= th && data[idx+1] >= th && data[idx+2] >= th)
    {
      br.y = i;
      break;
    }
    idx -= canvasw * 4;
  }

  let ok = true;
  [tl,tr,bl,br].forEach(pt => ok &= goodPoint(pt));
  if (ok)
    return {tl:tl,tr:tr,bl:bl,br:br};
  else
  {
    return null;
  }
}

function goodPoint(pt)
{
  return pt.x !== -1 && pt.y !== -1;
}

function sendClick(x,y,w,h,text)
{
  console.log('sendClick',x,y,w,h,text);
  if (wrtc && wrtc.sendChannel)
    wrtc.sendChannel.send(`${x},${y},${w},${h},text`);
}

let currentMark = null;

/*correctedcanvas.addEventListener('click',function (evt) {
    evt.preventDefault();
    evt.stopPropagation();
    let x = evt.pageX;
    let y = evt.pageY;
    let rect = correctedcanvas.getBoundingClientRect();
    x -= rect.left;
    y -= rect.top;
    x = (x * 100 / correctedcanvas.offsetWidth) | 0;
    y = (y * 100 / correctedcanvas.offsetHeight) | 0;
    console.log(x,y);
    sendClick(x,y,30,15,'Tap');
});*/

correctedcanvas.addEventListener('mousedown',function (evt) {
    evt.preventDefault();
    evt.stopPropagation();
    let x = evt.pageX;
    let y = evt.pageY;
    let rect = correctedcanvas.getBoundingClientRect();
    x -= rect.left;
    y -= rect.top;
    x *= correctedcanvas.width / rect.width;
    y *= correctedcanvas.height / rect.height;
    currentMark = {px:x,py:y,cx:x+2,cy:y+2};
});

correctedcanvas.addEventListener('mouseup',function (evt) {
    evt.preventDefault();
    evt.stopPropagation();
    if (!currentMark)
      return;
    let x1 = Math.min(currentMark.px,currentMark.cx);
    let y1 = Math.min(currentMark.py,currentMark.cy);
    let x2 = Math.max(currentMark.px,currentMark.cx);
    let y2 = Math.max(currentMark.py,currentMark.cy);


    x1 = (x1 * 100 / correctedcanvas.width) | 0;
    y1 = (y1 * 100 / correctedcanvas.height) | 0;
    x2 = (x2 * 100 / correctedcanvas.width) | 0;
    y2 = (y2 * 100 / correctedcanvas.height) | 0;

    let w = x2 - x1;
    let h = y2 - y1;

    currentMark = null;

    sendClick(x1,y1,w,h,'Tap');
});

correctedcanvas.addEventListener('mouseout',function (evt) {
    evt.preventDefault();
    evt.stopPropagation();
    currentMark = null;
});
correctedcanvas.addEventListener('mousemove',function (evt) {
    evt.preventDefault();
    evt.stopPropagation();
    if (!currentMark)
      return;
    let x = evt.pageX;
    let y = evt.pageY;
    let rect = correctedcanvas.getBoundingClientRect();
    x -= rect.left;
    y -= rect.top;
    x *= correctedcanvas.width / rect.width;
    y *= correctedcanvas.height / rect.height;
    currentMark.cx = x;
    currentMark.cy = y;
    //drawCurrentMark();
});

document.querySelector('#video').addEventListener('loadedmetadata',function (evt) {
  console.log('video loaded');
  drawVideo();
},false);

function b1ContainsBox2(b1,b2)
{
  if (b2.x1 > b1.x2)
    return false;
  if (b2.x2 < b1.x1)
    return false;
  if (b2.y1 > b1.y2)
    return false;
  if (b2.y2 < b1.y1)
    return false;
  return true;
}

function canMergeImageBoxes(a,b) {
  if (!b)
    return null;
  if (!(b1ContainsBox2(a,b) || b1ContainsBox2(b,a)))
  {
    if ((a.y2-a.y1<=1 || b.y2-b.y1<=1) && (a.x2-a.x1>15 || b.x2-b.x1>15))
      return null;
  }
  if (a.x1 > b.x2)
    return null;
  if (b.x1 > a.x2)
    return null;
  if (a.y1 > b.y2)
    return null;
  if (b.y1 > a.y2)
    return null;
  return {x1:Math.min(a.x1,b.x1),y1:Math.min(a.y1,b.y1),x2:Math.max(a.x2,b.x2),y2:Math.max(a.y2,b.y2)};
}

function mergeAll(array) {
  var encore = true;
  var len = array.length;
  while (encore)
  {
    encore = false;
    for (var i=0;i<len-1;i++)
    {
      var b1 = array[i];
      if (b1 === null)
        continue;
      for (var j=i+1;j<len;j++)
      {
        var b2 = array[j];
        if (b2 === null)
          continue;
        var mergedBox = canMergeImageBoxes(b1, b2);
        if (mergedBox !== null) {
          array[i] = mergedBox;
          array[j] = null;
          encore = true;
          break;
        }
      }
    }
  }
  return array.filter(a => a !== null);
}

function canny(canvas,showcanny)
{
  let ctx = canvas.getContext('2d');
  let img_u8 = new jsfeat.matrix_t(canvas.width, canvas.height, jsfeat.U8C1_t);
  let imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
  jsfeat.imgproc.grayscale(imageData.data, canvas.width, canvas.height, img_u8);
  var r = 1;
  var kernel_size = (r+1) << 1;
  jsfeat.imgproc.gaussian_blur(img_u8, img_u8, kernel_size, 0);
  jsfeat.imgproc.canny(img_u8, img_u8, 0, 100);
  /*let scaler = canvas.width;
  if (canvas.height < scaler) {
      scaler = canvas.height;
  }
  scaler = scaler * .4;
  let h = jsfeat.imgproc.hough_transform(img_u8, 1, (Math.PI / 540), scaler);
  var lines = [];
  for (var i = 0; i < h.length; i++) {

      var rho = h[i][0];
      var theta = h[i][1];

      var a = Math.cos(theta);
      var b = Math.sin(theta);

      var x0 = a * rho;
      var y0 = b * rho;

      var pt1 = {};
      pt1.x = Math.round(x0 + 1000 * (-b));
      pt1.y = Math.round(y0 + 1000 * (a));
      var pt2 = {};
      pt2.x = Math.round(x0 - 1000 * (-b));
      pt2.y = Math.round(y0 - 1000 * (a));

      var line = {};
      line.start = pt1;
      line.end = pt2;
      lines.push(line);

  }*/
  //console.log(img_u8);
  let label = new Uint16Array(canvas.width * canvas.height);
  BlobExtractionLaurent_u8(label,img_u8.data,canvas.width, canvas.height);
  let boxes = BlobBounds_u8(label, canvas.width, canvas.height);
  //console.log(boxes);

  if (showcanny)
  {
    // render result back to canvas
    var data_u32 = new Uint32Array(imageData.data.buffer);
    var alpha = (0xff << 24);
    var i = img_u8.cols*img_u8.rows, pix = 0;
    while(--i >= 0) {
        pix = img_u8.data[i];
        data_u32[i] = alpha | (pix << 16) | (pix << 8) | pix;
    }
    ctx.putImageData(imageData, 0, 0);
  }

  boxes = boxes.filter((item, i) => {
    let w = item.x2 - item.x1;
    let h = item.y2 - item.y1;
    if (w > canvas.width / 4 || h > canvas.height / 2)
    {
      return false;
    }
    else if (w > 48 && h > 32)
    {
      return true;
    }
  });

  boxes = mergeAll(boxes);
  ctx.strokeStyle = 'yellow';
  ctx.lineWidth = 3;
  boxes.forEach((item, i) => {
    let w = item.x2 - item.x1;
    let h = item.y2 - item.y1;
    ctx.strokeRect(item.x1,item.y1,w,h);
  });

  /*ctx.strokeStyle = 'yellow';
  ctx.lineWidth = 3;
  lines.forEach((item, i) => {
    ctx.beginPath();
    ctx.moveTo(item.start.x,item.start.y);
    ctx.lineTo(item.end.x,item.end.y);
    ctx.stroke();
  });*/

}

function binarize(c)
{
  let canvasw = c.width;
  let canvash = c.height;
  c.style.objectFit = 'contain';
  let ctx = c.getContext('2d');
  //ctx.drawImage(image,0,0,canvasw,canvash);
  //results.appendChild(c)
  //return
  let d = ctx.getImageData(0,0,canvasw,canvash);
  let data = d.data;
  //let idx = 0;
  let TH = 5;

  let resData = ctx.createImageData(canvasw,canvash);
  let res = resData.data;
  function gray(pixels,i)
  {
    return pixels[i];//3*pixels[i] + 4*pixels[i + 1] + pixels[i + 2] >>> 3;
    //return pixels[i]*.299 + pixels[i + 1]*.587 + pixels[i + 2]*.114;
  }

  /*for (let j=0;j<canvash;j++)
  {
    for (let i=0;i<canvasw-1;i++)
    {
      let idx = (canvasw * j + i) * 4;
      let g1 = gray(data,idx);
      let g2 = gray(data,idx+4);
      let redd = Math.abs(g1 - g2);
      if (redd < TH)
      {
        res[idx] = 0;
      }
      else {
        res[idx] = 255;
      }
    }
  }
  let stride = 4 * canvasw;
  for (let i=0;i<canvasw;i++)
  {
    for (let j=0;j<canvash-1;j++)
    {
      let idx = (canvasw * j + i) * 4;
      let g1 = gray(data,idx);
      let g2 = gray(data,idx+stride);
      let redd = Math.abs(g1 - g2);
      if (redd < TH && res[idx] === 0)
      {
        res[idx] = 0;
      }
      else {
        res[idx] = 255;
      }
    }
  }*/

  let n = 4 * canvasw * canvash;
  let THW = 100;
  for (let i=0;i<n;i+=4)
  {
    if (data[i] > THW && data[i+1] > THW && data[i+2] > THW)
    //if (data[i] < 160 && data[i+1] < 160 && data[i+2] > 160)
    {
      res[i] = 255;
      res[i+1] = 255;
      res[i+2] = 255;
    }
    else {
      res[i] = 0;
      res[i+1] = 0;
      res[i+2] = 0;
    }
    res[i+3] = 255;
  }
  ctx.putImageData(resData,0,0);
  //results.appendChild(c);
}
/* test widget detector */
/*['download-root.png','download-print.png','download-device.png'].forEach((item, i) => {
  let img = document.createElement('img');
  img.onload = function () {
    let c = document.createElement('canvas');
    results.appendChild(c);
    c.width = this.naturalWidth;
    c.height = this.naturalHeight;
    let ctx = c.getContext('2d');
    ctx.filter = 'grayscale(0%) blur(2px)';//contrast(100%)
    ctx.drawImage(this,0,0);
    //binarize(c);
    canny(c)
  }
  img.src = '/static/videoStor/' + item;
});*/


/* function to test detectCorners */
/*
  let img = document.createElement('img');
  img.onload = function () {
  let c = document.createElement('canvas');
  c.width = this.naturalWidth;
  c.height = this.naturalHeight;
  canvasw = c.width;
  canvash = c.height;
  c.getContext('2d').drawImage(this,0,0,canvasw,canvash);
  console.log(detectCorners(c.getContext('2d')));
}
img.src = '/static/videoStor/download.png';*/
</script>
